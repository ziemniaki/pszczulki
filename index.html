<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Energetyczna Pasieka 2.0</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    /***************************************************************
     * Canvas setup
     ***************************************************************/
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    function resize(){
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    /***************************************************************
     * Audio setup with delay effect
     ***************************************************************/
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.4;
    masterGain.connect(audioCtx.destination);
    const delay = audioCtx.createDelay();
    delay.delayTime.value = 0.25;
    const feedback = audioCtx.createGain();
    feedback.gain.value = 0.5;
    delay.connect(feedback);
    feedback.connect(delay);
    delay.connect(masterGain);

    function resumeAudioContext(){
      if(audioCtx.state === 'suspended') audioCtx.resume();
    }

    /***************************************************************
     * Honeycomb grid generation
     ***************************************************************/
    const hexRadius = 40;
    const hexHeight = Math.sqrt(3) * hexRadius;
    const hexWidth = 2 * hexRadius;
    const horizDist = hexWidth * 0.75;

    let hexagons = [];
    function buildGrid(){
      hexagons = [];
      const cols = Math.ceil(canvas.width / horizDist) + 1;
      const rows = Math.ceil(canvas.height / (hexHeight * 0.75)) + 1;
      for(let row=0; row<rows; row++){
        for(let col=0; col<cols; col++){
          const x = col*horizDist + ((row%2)*horizDist/2);
          const y = row*(hexHeight*0.75);
          hexagons.push({
            row,
            col,
            x,
            y,
            energy:0,
            active:false,
            assignedPitches:[],
            neighbors:[]
          });
        }
      }
      hexagons.forEach(h => {
        h.neighbors = hexagons.filter(o => {
          if(o===h) return false;
          const dx=o.x-h.x; const dy=o.y-h.y;
          const dist=Math.sqrt(dx*dx+dy*dy);
          return dist < hexRadius*1.9;
        });
      });
    }
    buildGrid();

    /***************************************************************
     * Pitch assignment
     ***************************************************************/
    const scaleRatios = [1,9/8,5/4,45/32,3/2,5/3,15/8];
    function getRandomUniqueElements(arr,count){
      const tmp=arr.slice();
      const out=[];
      for(let i=0;i<count && tmp.length>0;i++){
        const idx=Math.floor(Math.random()*tmp.length);
        out.push(tmp.splice(idx,1)[0]);
      }
      return out;
    }
    function assignPitches(){
      hexagons.forEach(h=>{
        const ratios=getRandomUniqueElements(scaleRatios,6);
        h.assignedPitches = ratios.map(r => {
          const octave=Math.floor(Math.random()*8);
          return 420*r*Math.pow(2,octave-3);
        });
      });
    }
    assignPitches();

    /***************************************************************
     * Particle system
     ***************************************************************/
    const particles = [];
    function spawnParticles(x,y,count,hue){
      for(let i=0;i<count;i++){
        const angle=Math.random()*Math.PI*2;
        const speed=Math.random()*50+20;
        particles.push({
          x,
          y,
          vx:Math.cos(angle)*speed,
          vy:Math.sin(angle)*speed,
          life:1.5,
          size:2+Math.random()*2,
          hue
        });
      }
    }

    function updateParticles(dt){
      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i];
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.vx*=0.98;
        p.vy*=0.98;
        p.life -= dt;
        if(p.life<=0) particles.splice(i,1);
      }
    }

    function drawParticles(){
      particles.forEach(p=>{
        ctx.fillStyle=`hsla(${p.hue},100%,70%,${Math.max(0,p.life)})`;
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
        ctx.fill();
      });
    }

    /***************************************************************
     * Drawing functions
     ***************************************************************/
    let globalHue=0;
    function drawHexagon(h){
      ctx.save();
      ctx.beginPath();
      for(let i=0;i<6;i++){
        const ang=Math.PI/180*(60*i-30);
        const x=h.x+hexRadius*Math.cos(ang);
        const y=h.y+hexRadius*Math.sin(ang);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      const bright=h.energy/100;
      const hue=(globalHue+h.row*10+h.col*10)%360;
      ctx.fillStyle=`hsl(${hue},70%,${20+bright*50}%)`;
      if(h.energy>0){
        ctx.shadowColor=`hsla(${hue},100%,70%,${bright})`;
        ctx.shadowBlur=80*bright;
      }
      ctx.fill();
      ctx.strokeStyle='rgba(50,30,10,0.6)';
      ctx.stroke();
      ctx.restore();
    }

    /***************************************************************
     * Sound
     ***************************************************************/
    function playChord(h){
      let num=0;
      if(h.energy>=10 && h.energy<50) num=3;
      else if(h.energy>=50 && h.energy<90) num=4;
      else if(h.energy>=90 && h.energy<100) num=5;
      else if(h.energy>=100) num=6;
      if(num===0) return;
      const freqs=getRandomUniqueElements(h.assignedPitches,num);
      freqs.forEach(f=>playTone(f,0.7));
    }

    function playTone(frequency,duration){
      const now=audioCtx.currentTime;
      const osc=audioCtx.createOscillator();
      osc.type='sawtooth';
      osc.frequency.setValueAtTime(frequency,now);
      const filter=audioCtx.createBiquadFilter();
      filter.type='lowpass';
      filter.frequency.value=frequency*2;
      const gain=audioCtx.createGain();
      gain.gain.setValueAtTime(0,now);
      gain.gain.linearRampToValueAtTime(0.3,now+0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001,now+duration);
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(delay);
      gain.connect(masterGain);
      osc.start(now);
      osc.stop(now+duration);
    }

    /***************************************************************
     * Interaction
     ***************************************************************/
    let mouseDown=false;
    canvas.addEventListener('pointerdown',e=>{mouseDown=true;handleInteraction(e);resumeAudioContext();});
    canvas.addEventListener('pointermove',e=>{if(mouseDown) handleInteraction(e);});
    window.addEventListener('pointerup',()=>{mouseDown=false;});

    canvas.addEventListener('click',e=>{
      const {x,y}=getPointerPos(e);
      const h=getHexagonAt(x,y);
      if(h){
        h.active=!h.active;
        spawnParticles(h.x,h.y,20,globalHue);
        playChord(h);
      }
    });

    function handleInteraction(e){
      const {x,y}=getPointerPos(e);
      const h=getHexagonAt(x,y);
      if(h){
        h.energy=Math.min(100,h.energy+50);
        spawnParticles(h.x,h.y,10,globalHue);
        playChord(h);
      }
    }
    function getPointerPos(e){
      const rect=canvas.getBoundingClientRect();
      return {x:e.clientX-rect.left,y:e.clientY-rect.top};
    }

    function pointInPolygon(point,vertices){
      let inside=false;
      for(let i=0,j=vertices.length-1;i<vertices.length;j=i++){
        const xi=vertices[i].x, yi=vertices[i].y;
        const xj=vertices[j].x, yj=vertices[j].y;
        const intersect=((yi>point.y)!=(yj>point.y)) &&
          (point.x<(xj-xi)*(point.y-yi)/(yj-yi)+xi);
        if(intersect) inside=!inside;
      }
      return inside;
    }

    function getHexagonAt(x,y){
      for(let i=0;i<hexagons.length;i++){
        const h=hexagons[i];
        const verts=[];
        for(let j=0;j<6;j++){
          const a=Math.PI/180*(60*j-30);
          verts.push({x:h.x+hexRadius*Math.cos(a),y:h.y+hexRadius*Math.sin(a)});
        }
        if(pointInPolygon({x,y},verts)) return h;
      }
      return null;
    }

    /***************************************************************
     * Simulation
     ***************************************************************/
    let lastTime=performance.now();
    const activeRate=80;
    const decayRate=5;
    const spillageInterval=0.1; // seconds
    const spillageThreshold=30;
    const spillageAmount=50;
    const spillageProb=0.2;
    let spillageTimer=0;

    function update(time){
      const dt=(time-lastTime)/1000;
      lastTime=time;
      globalHue=(globalHue+dt*20)%360;

      hexagons.forEach(h=>{
        if(h.active) h.energy=Math.min(100,h.energy+activeRate*dt);
        else h.energy=Math.max(0,h.energy-decayRate*dt);
      });

      spillageTimer+=dt;
      if(spillageTimer>spillageInterval){
        spillageTimer=0;
        hexagons.forEach(h=>{
          if(h.energy>=spillageThreshold){
            h.neighbors.forEach(n=>{
              if(Math.random()<spillageProb && h.energy>=spillageAmount){
                h.energy-=spillageAmount;
                n.energy=Math.min(100,n.energy+spillageAmount);
                spawnParticles(n.x,n.y,5,globalHue);
                playChord(n);
              }
            });
          }
        });
      }

      updateParticles(dt);
      draw();
      requestAnimationFrame(update);
    }

    function draw(){
      const grad=ctx.createRadialGradient(canvas.width/2,canvas.height/2,100,canvas.width/2,canvas.height/2,Math.max(canvas.width,canvas.height));
      grad.addColorStop(0,`hsl(${(globalHue+180)%360},40%,10%)`);
      grad.addColorStop(1,`hsl(${globalHue},40%,20%)`);
      ctx.fillStyle=grad;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      hexagons.forEach(drawHexagon);
      drawParticles();
    }

    requestAnimationFrame(update);
  </script>
</body>
</html>
